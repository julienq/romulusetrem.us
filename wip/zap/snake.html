<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Snake</title>
    <meta charset="UTF-8">
    <meta http-equiv="cache-control" content="no-cache">
    <script src="../../flexo.js"></script>
    <script src="zap.js"></script>
    <style>
      body { font-family: Univers, "Helvetica Neue", Helvetica, sans-serif; }
      .zap-frame { background-color: black }
      #zap:focus { outline: 0; }
    </style>
  </head>
  <body>
    <div id="zap"></div>
    <script>

      zap.title = "Snake";
      var frame = zap.frame(320, 460);
      var scene = zap.scene();
      frame.add_scene(scene);

      // Add an apple to the scene, which is just a red circle
      scene.add((function(r)
      {
        var apple = zap.svg("circle", { fill: "red", r: r, id: "apple" });
        // apple.update_rate = 0;
        // apple.rate_mult = 1;
        apple.reset = function() {
          this.cx = r + flexo.random_int(0, this.scene.frame.width - 2 * r);
          this.cy = r + flexo.random_int(0, this.scene.frame.width - 2 * r);
        };
        flexo.getter_setter(apple, "r", function() { return r; });
        return apple;
      })(10));

      scene.$apple.reset();

      // Add a snake to the scene. x and y are the coordinates of its head;
      // direction is 0 for West, 1 for North, 2 for East and 3 forst South (so
      // the corresponding angle is direction * Math.PI / 4); length and girth
      // are its dimensions.
      scene.add((function(x, y, direction, length, girth)
      {
        // The snake is a path (could also be a polyline.) By giving it an id,
        // we can then refer to it as scene.$snake in the scene
        var snake = zap.svg("path", { "stroke-width": girth, stroke: "#8f0",
          "stroke-linecap": "round", "stroke-linejoin": "round", fill: "none",
          id: "snake" });

        // Initially only one segment, as the snake moves new segments are
        // created and removed (see grow and move below.) Every segment is a
        // pair (direction, length)
        var segments = [[direction, length]];

        // Steer the snake in the given direction. We prevent the snake from
        // turning if it would immediately go back on itself (but the player
        // might still accidentally intersect itself.)
        Object.defineProperty(snake, "direction", { enumerable: true,
            get: function() { return direction; },
            set: function(d) {
              if (Math.abs(d - direction) !== 2 &&
                (segments[0][1] > girth ||
                 (segments.length > 1 && Math.abs(d - segments[1][0]) !== 2))) {
                direction = d;
              }
            }
          });

        // Set the d parameter of the path according to the position of the head
        // and the list of segments.
        snake.update_path = function()
        {
          this.element.setAttribute("d", "M{0},{1}".fmt(x, y) +
            segments.map(function(seg) {
                return ["h-", "v", "h", "v-"][seg[0]] + seg[1].toString();
              }).join(""));
        };

        // Make the snake grow by a length of l. If the direction has not
        // changed, then the first segment will grow, otherwise a new one is
        // created.
        snake.grow = function(l)
        {
          if (segments[0][0] === direction) {
            segments[0][1] += l;
          } else {
            segments.unshift([direction, l]);
          }
          x += l * [1, 0, -1, 0][direction];
          y += l * [0, -1, 0, 1][direction];
          this.update_path();
        };

        // Move the snake by l. This is actually the same as making the snake
        // grow but we just remove as much length from its tail (i.e., last
        // segments), possibly removing segments if their length becomes 0.
        snake.move = function(l)
        {
          for (var last = segments[segments.length - 1], d = l; d > 0;) {
            last[1] -= d;
            if (last[1] < 0) {
              d = -last[1];
              segments.pop();
              last = segments[segments.length - 1];
            } else {
              d = 0;
            }
          }
          snake.grow(l);
        }

        // Test whether the snake self intersects, that is if the head falls
        // withing a distance of `girth` from any segment after the first two.
        snake.self_intersect = function()
        {
          if (segments.length < 2) return false;
          var x1 = x + segments[0][1] * [-1, 0, 1, 0][segments[0][0]];
          var y1 = y + segments[0][1] * [0, 1, 0, -1][segments[0][0]];
          var x2 = x1 + segments[1][1] * [-1, 0, 1, 0][segments[1][0]];
          var y2 = y1 + segments[1][1] * [0, 1, 0, -1][segments[1][0]];
          for (var i = 2; i < segments.length; ++i) {
            x1 = x2;
            y1 = y2;
            x2 += segments[i][1] * [-1, 0, 1, 0][segments[i][0]];
            y2 += segments[i][1] * [0, 1, 0, -1][segments[i][0]];
            if ((x1 === x2 && Math.abs(x - x2) < girth && between(y, y1, y2)) ||
                (y1 === y2 && Math.abs(y - y2) < girth && between(x, x1, x2))) {
              return true;
            }
          }
          return false;
        };

        // Set the initial path and getter/setters for x, y and girth (length
        // can only change through grow())
        snake.update_path();
        flexo.getter_setter(snake, "x", function() { return x; });
        flexo.getter_setter(snake, "y", function() { return y; });
        flexo.getter_setter(snake, "girth", function() { return girth; },
          function(g) {
            girth = g;
            this.element.setAttribute("stroke-width", g);
          });

        return snake;

      })(frame.width / 2, frame.height / 2, 0, 40, 20));

      // Update the game for the next frame
      scene.tick = function(dt)
      {
        // Check change in direction
        if (this.frame.keys.right) {
          this.$snake.direction = this.$snake.switch ? 2 : 0;
        } else if (this.frame.keys.left) {
          this.$snake.direction = this.$snake.swtich ? 0 : 2;
        } else if (this.frame.keys.up) {
          this.$snake.direction = 1;
        } else if (this.frame.keys.down) {
          this.$snake.direction = 3;
        }
        // Move the snake
        this.$snake.move(dt / 5);
        // Check collisions
        if (this.$snake.x < 0 || this.$snake.x > frame.width ||
          this.$snake.y < 0 || this.$snake.y > frame.height ||
          this.$snake.self_intersect()) {
          // Die from running into a wall or itself!
          this.running = false;
        } else if (Math.pow(this.$snake.x - this.$apple.cx, 2) +
          Math.pow(this.$snake.y - this.$apple.cy, 2) <=
          Math.pow(this.$snake.girth / 2 + this.$apple.r, 2)) {
          // Eat the apple and grow
          this.$snake.grow(20);
          this.$apple.reset();
        }
      };

      // Check whether x is between x1 and x2, regardless of the the order of x1
      // and x2
      function between(x, x1, x2)
      {
        return x1 < x2 ? x >= x1 && x <= x2 : x >= x2 && x <= x1;
      }

      /*
      scene.new_apple = function()
      {
        this.$apple.random_position();
        while (this.$snake.is_in_path(this.$apple.cx, this.$apple.cy, 10)) {
          this.$apple.random_position();
        }
        this.$apple.score = this.$apple.max_score =
          Math.round((Math.abs(this.$apple.cx - this.$snake.x) +
            Math.abs(this.$apple.cy - this.$snake.y)) / 2);
        var r = Math.random();
        this.$apple.mult = 1;
        if (this.$apple.update_rate-- <= 0) this.$apple.rate_mult = 1;
        this.$apple.switch = false;
        if (r < 0.05 && this.$snake.length > 1) {
          this.$apple.element.setAttribute("fill", "#acbe2a");
          this.$apple.mult = 1;
        } else if (r < 0.1) {
          this.$apple.element.setAttribute("fill", "#08f");
          this.$apple.mult = 5;
          this.$apple.switch = true;
        } else if (r < 0.15) {
          this.$apple.element.setAttribute("fill", "#80f");
          this.$apple.rate_mult = 0.5;
          this.$apple.update_rate = 5;
        } else if (r < 0.25) {
          this.$apple.element.setAttribute("fill", "#fcad00");
          this.$apple.mult = 2;
        } else {
          this.$apple.element.setAttribute("fill", "#ff0000");
        }
      }
      */

    </script>
  </body>
</html>
